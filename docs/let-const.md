---
order: 1
---
## var,let和const
### ECS(Execution Context Stack)执行环境栈

实质：栈内存(从内存当中分配出来的一块内存),遵守先进后出原则。  
作用：执行环境栈用来存储执行代码期间创建的所有(EC)执行上下文。并确保程序能够按照正确的顺序被执行。  
创建时间：在首次运行js代码时创建

### 作用域（Scope）
+ 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。
+ 作用域是可访问变量的集合。
+ 值和表达式在其中 "可见" 或可被访问到的上下文。
+ 分为 全局作用域/局部作用域（函数作用域与块级作用域）

### 上下文（Context）
+ 上下文是一段程序运行所需要的最小数据集合
作用域是当前上下文中，按照具体规则能够访问到的标识符（变量）的范围。有时候上下文、环境、作用域是同义词；上下文指代的是整体环境，作用域关注的是标识符（变量）的可访问性（可见性）。上下文确定了，根据具体编程语言的作用域规则，作用域也就确定了。  
作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值，这就是上下文与作用域的关系。

### EC(Execution Context)执行上下文(词法作用域)
实质： 代码执行所在的执行上下文，或者代码执行所处的作用域，实质上是执行环境栈中的一块栈内存。  
作用： 在JS代码执行中，为了区分全局和函数执行所处的不同的作用域（目的是为了区分每个执行上下文中代码的独立性）  
执行上下文又分为  
+ EC(G): global全局执行上下文：
    + 当打开页面时，首次加载一个Js文件或者运行一段Js代码，则会在【全局代码执行之前】【先创建一个全局的执行上下文EC(G)】,并将这个全局执行上下文压入【执行环境栈】中。
    + 而在这个js运行的生命周期中，【EC(G)将只创建一次，只有一个】，只有页面关闭时才会释放掉。
    + 刷新页面时，会把之前的上下文全都释放调，然后创建全新的上下文。
+ EC(xx):xx函数私有执行上下文： 
    + 在全局执行上下文创建并压入执行环境栈中之后，运行代码的过程当中，【每当有函数被调用，都会创建一个新的私有函数执行上下文并压入栈中，这个私有上下文可以保护里面的私有变量和外界互不干扰 闭包的保护机制】
    + 【函数执行上下文可存在无数个】
    + 【即使是同一个函数但每一次被调用，都会创建一个新的私有上下文。】
    + 每当一个函数执行完毕，则这个函数的私有执行上下文也将从栈中弹出，等到所有函数都运行完毕，要关闭页面的时候，全局上下文也将出栈释放，程序运行结束
    + 只要当前上下文中的某些内容，被当前上下文以外的东西占用，那么当前上下文是不能被释放的（上下文当中存储的变量等信息也保存下来了） 【闭包的保存机制】

    ![Image text](https://user-gold-cdn.xitu.io/2019/3/17/1698ac2c8ca10784?imageslim)
```javascript
function foo(b) {
    var a = 5;
    return a * b + 10;
}
function bar(x) {
    var y = 3;
    return foo(x*y);
}
console.log(bar(6));
```
### 闭包
+ 闭包是一种机制
+ 闭包的作用：保护/保存  

1. 它是函数运行时产生的机制，函数执行会在执行环境栈【ECStack】中形成一个全新的私有上下文【EC(私有)】并且在私有上下文中声明新的作用域【scope】和作用域链【scope-chain】，可以保护里面的私有变量【Ao】和外界【Vo】互不干扰 【保护机制】
2. 且若私有上下文中的某些内容，被当前上下文以外的东西占用，那么当前上下文是不能被出栈释放的（这样私有变量及它的值等也不会被释放掉）【保存机制】
3. 大量应用闭包一定会导致内存消耗，但是闭包的保护和保存作用，在真实开发中我们还是需要使用，所以要合理使用闭包
      
### VO(Variable Object)变量对象
+ 作用： 是一个用来保存 【当前上下文】 中 【所有变量】 的对象（存储空间），这个对象（存储空间）被创建在当前上下文中。
+ 在不同的上下文中，有不同的表现和叫法，但都是变量对象
+ #### VO(G)全局变量对象：
    1. 【对于VAR创建的变量来说】 在【全局执行上下文EC(G)中】，全局变量对象 VO(G) 的具体表现就是【全局对象(GO)】，因为【所有VAR创建的全局变量】其实都会映射给【全局对象(GO)】一份，作为其属性，【而变量对象 VO 的作用是要保存当前上下文中的所有变量，所以此时的变量对象 VO 实际上是指向的全局对象】。【所以会映射给window一份】，则全局对象(GO)就是 window，
        + 【这里理解为VAR创建对象时VO(G)和全局对象有映射关系】
    2. 【对于LET/CONST创建的变量来说】,只是在VO(G)中创建了一个变量，并不会映射给全局一份。
+ #### AO(Active Object)私有变量对象：
    1.叫法不同，实质相同。
    2. 而在【函数执行上下文EC(XX)中】，因为【私有变量对象 AO(xx)】 是要保存当前私有上下文中所有的变量，而一个函数内的变量包括：形参变量、局部变量、自身函数对象引用变量、arguments、this。 为了保存这些变量，所以特意创建了一个对象，称它为【活动对象(私有变量对象)AO(xx)】，函数内所需的变量就都保存在 【私有变量对象AO(xx)】 中，所以在函数执行上下文中，变量对象 VO 的具体表现也就是【私有变量对象AO(xx)】。
+ #### GO(Global Object)全局对象：
    与VO和AO没有什么太大关系，是预定义的对象，【浏览器把所有后期需要供JS调取使用的属性和方法(内置)，都放置在了GO当中。并且在全局当中创建一个叫做window的变量指向它。】通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。【window.什么都是去GO当中找。】


### 变量提升
为什么出现变量提升：尽管JavaScript是一门解释型语言，但他在执行时像是在编译或者像是一种编译和解释的混合。  
JS加载包含预编译和执行两个阶段  
+ 编译阶段，对所有的var变量和function进行扫描，并将var变量初始化为undefined类型，而function则被初始化为函数值。
+ 执行阶段，JS从上面往下面依顺序执行，遇到var变量便进行赋值(因此，在赋值之前进行调用的话会出现错误)，遇到函数变量的话会从活动对象中寻找函数  
当你看到<code> var a = 2; </code>时，可能会认为这是一个声明，但实际上 Javascript 会将其看成两个声明：var a ; 和 a ＝ 2；并且在不同阶段执行。var a 是在编译阶段进行的，而 a = 2 会被留在原地等待执行阶段。这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面，这个过程就叫做变量提升。  
### 变量声明
变量声明分为显示声明和隐式声明（不建议使用）  
显示声明：
+ var：遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到undefined的原因由来（**var的声明和初始化过程都提升了**）
+ let：解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错xx is not defined，这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行（**let只是声明过程提升，初始化过程并没有提升**）
+ const、class都是同let一样的道理
+ function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高（函数声明会被提升，而函数表达式却不会被提升）
隐式声明：
+ 当赋值给未声明的变量, 则执行赋值后, 该变量会被隐式地创建为全局变量（它将成为全局对象的属性）。
```javascript
var a = 123;
b = 456;
var attrA = Object.getOwnPropertyDescriptor(window,'a');
var attrB = Object.getOwnPropertyDescriptor(window,'b');
console.log(attrA);//{value: 123, writable: true, enumerable: true, configurable: false}
console.log(attrB);//{value: 456, writable: true, enumerable: true, configurable: true}
delete window.a;
delete window.b;
console.log(a);
console.log(b); // b is not defined  
```    
*<code>Object.getOwnPropertyDescriptor() </code>方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）*  
*<code>configurable</code>: 当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认值为 false。*  

显示声明与隐式声明的区别：  
1. 显示声明变量（带var）相当于给VO(G)全局变量对象添加一个变量，同时映射给window【全局对象】设置一个属性
2. 隐式声明变量（不带var）相当于只给window【全局对象】设置一个属性
3. 显示声明变量的configurable默认**false**，隐式声明变量的configurable默认**true**  

#### LHS查询与RHS查询
+ LHS（Left-hand Side）：查找的目的是对变量进行赋值，就会使用LHS查询（试图找到变量的容器本身，从而可以对其赋值）
+ RHS（Right-hand Side）：查找的目的是获取变量的值，就会使用RHS查询
+ LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后到达全局作用域，无论找到或没找到都将停止。
+ 不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError（引用错误） 异常（严格模式下）

### 内存分配：
JS 引擎中的内存分类：
+ 栈内存（作用域）供js代码执行的环境，保存基本数据类型（boolean,null,undefined,number,string,symbol,bigint）（线性结构，后进先出，便于管理）
+ 堆内存：存储引用数据类型（混沌，杂乱无章，方便存储和开辟内存空间）（ 闭包变量是存在堆内存中的。）
内存分配：
+ var：会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针
+ let：是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错
+ const：也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性
```javascript
        var a=1;
        const b=2;
        let c=3;
        {
            let d=4;
            const e={a};
            var aa=b;
        }
        function aFun() {
            var aaa = 0
            aaaa = 0
            console.log(a,b,c,aa)
            // console.log(d,e)
        }
        aFun()
        console.log(aaaa)
        // console.log(aaa)
```    
### 小结
- 使用var声明的变量，其作用域为该语句所在的**函数**内，且**存在**变量提升现象；
- 使用let声明的变量，其作用域为该语句所在的**代码块**内，**不存在**变量提升；（代码块：{}）
- 使用const声明的是常量，其作用域为该语句所在的**代码块**内，**不存在**变量提升，在后面出现的代码中**不能**再修改该常量的值（栈内存在的值和地址）。