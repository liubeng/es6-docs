---
order: 1
---
## var,let和const

### 执行上下文
执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行
+ 全局执行上下文： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中，一个程序中只能存在一个全局执行上下文。它做了两件事：
    1. 创建一个全局对象，在浏览器中这个全局对象就是window 对象。
    2. 将 this 指针指向这个全局对象。
+ 函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。
+ Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文。（不推荐，不常用，暂不讨论。）
执行上下文的生命周期包括三个阶段：**创建阶段**→执行阶段→回收阶段
+ 创建阶段：
    + 创建变量对象：首先初始化函数的参数arguments，**变量（函数）提升**和**变量声明**。
    + 创建作用域链
    + 确定this指向
+ 执行阶段
    + 执行变量赋值、代码执行
+ 回收阶段
    + 执行上下文出栈等待虚拟机回收执行上下文
### 变量提升
为什么出现变量提升：JavaScript是一门**编译语言**。  
JS加载包含预编译和执行两个阶段  
+ 编译阶段，对所有的var变量和function进行扫描，并将var变量初始化为undefined类型，而function则被初始化为函数值。
+ 执行阶段，JS从上面往下面依顺序执行，遇到var变量便进行赋值(因此，在赋值之前进行调用的话会出现错误)，遇到函数变量的话会从活动对象中寻找函数  
当你看到<code> var a = 2; </code>时，可能会认为这是一个声明，但实际上 Javascript 会将其看成两个声明：var a ; 和 a ＝ 2；并且在不同阶段执行。var a 是在编译阶段进行的，而 a = 2 会被留在原地等待执行阶段。这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面，这个过程就叫做变量提升。  
### 变量声明
变量声明分为显示声明和隐式声明（不建议使用）  
显示声明：
+ var：遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到undefined的原因由来（**var的声明和初始化过程都提升了**）
+ let：解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错xx is not defined，这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行（**let只是声明过程提升，初始化过程并没有提升**）
+ const、class都是同let一样的道理
+ function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高（函数声明会被提升，而函数表达式却不会被提升）
隐式声明：
+ 当赋值给未声明的变量, 则执行赋值后, 该变量会被隐式地创建为全局变量（它将成为全局对象的属性）。

        var a = 123;
        b = 456;
        var attrA = Object.getOwnPropertyDescriptor(window,'a');
        var attrB = Object.getOwnPropertyDescriptor(window,'b');
        console.log(attrA);//{value: 123, writable: true, enumerable: true, configurable: false}
        console.log(attrB);//{value: 456, writable: true, enumerable: true, configurable: true}
        delete window.a;
        delete window.b;
        console.log(a);
        console.log(b); // b is not defined
*<code>Object.getOwnPropertyDescriptor() </code>方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）*  
*<code>configurable</code>: 当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认值为 false。*  

显示声明与隐式声明的区别：  
1. 如果都在全局，他们声明的都是**全局变量** 
2. 如果在函数中，显示声明的变量为**局部变量**，隐式声明的变量为**全局变量**
3. 显示声明变量的configurable默认**false**，隐式声明变量的configurable默认**true**  
讨论：隐式全局变量并不是真正的全局变量，但它们是全局对象的**属性**？（理由：属性是可以通过delete操作符删除的，而变量是不能的。）  

#### LHS查询与RHS查询
+ LHS（Left-hand Side）：查找的目的是对变量进行赋值，就会使用LHS查询（试图找到变量的容器本身，从而可以对其赋值）
+ RHS（Right-hand Side）：查找的目的是获取变量的值，就会使用RHS查询
+ LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后到达全局作用域，无论找到或没找到都将停止。
+ 不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）

### 内存分配：
JS 引擎中的内存分类：
+ 栈内存（作用域）供js代码执行的环境，保存基本数据类型（boolean,null,undefined,number,string,symbol,bigint）（线性结构，后进先出，便于管理）
+ 堆内存：存储引用数据类型（混沌，杂乱无章，方便存储和开辟内存空间）（ 闭包变量是存在堆内存中的。）
拓展：三者内存分配问题：
+ var：会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针
+ let：是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错
+ const：也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性

        debugger
        var a=1;
        const b=2;
        let c=3;
        {
            let d=4;
            const e={a};
            var aa=b;
        }
        function aFun() {
            var aaa = 0
            aaaa = 0
            console.log(a,b,c,aa)
            // console.log(d,e)
        }
        aFun()
        console.log(aaaa)
        // console.log(aaa)

### 小结
- 使用var声明的变量，其作用域为该语句所在的**函数**内，且**存在**变量提升现象；
- 使用let声明的变量，其作用域为该语句所在的**代码块**内，**不存在**变量提升；（代码块：{}）
- 使用const声明的是常量，其作用域为该语句所在的**代码块**内，**不存在**变量提升，在后面出现的代码中**不能**再修改该常量的值（栈内存在的值和地址）。