
## let和const

### 声明变量：
+ var：遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到undefined的原因由来（var的声明和初始化过程都提升了）
+ let：解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错xx is not defined，这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。如果let的那一行是赋值操作，则初始化和赋值同时进行（ let只是声明过程提升，初始化过程并没有提升）
+ const、class都是同let一样的道理
+ function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高

        debugger
        var a=1;
        const b=2;
        let c=3;
        {
            let d=4;
            const e=a;
            var aa=b;
        }
        function aFun() {
            var aaa = 0
            console.log(a,b,c,aa)
            // console.log(d,e)
        }
        aFun()
        // console.log(aaa)
        
+ 变量提升只是在当前函数的执行上下文
+ 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。
+ 如果查找的目的是对变量进行赋值，就会使用 LHS 查询；如果目的是获取变量的值，就会用 RHS 查询。
+ 赋值操作会导致 LHS 查询。 = 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作, 即都会导致 LHS 查询。
+ JavaScript 引擎首先会在代码执行前对其进行编译，像var a = 1 这样的声明会被分解成两个独立的步骤：
    1. 首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
    2. 接下来，a = 2会查询（LHS查询）变量 a 并对其进行赋值。
+ LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域，最后到达全局作用域，无论找到或没找到都将停止。
+ 不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）

### JS 引擎中的内存分类：
+ 栈内存（作用域）供js代码执行的环境，保存基本数据类型（boolean,null,undefined,number,string,symbol,bigint）（线性结构，后进先出，便于管理）
+ 堆内存：存储引用数据类型（混沌，杂乱无章，方便存储和开辟内存空间）（ 闭包变量是存在堆内存中的。）

### 内存分配：
+ var：会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针
+ let：是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错
+ const：也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性
   
